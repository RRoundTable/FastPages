<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" type="image/x-icon" href="/FastPages/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Abstract | fastpages</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Abstract" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="많은 방법론들이 depth estimation부분에서 성과를 보여주었다. 하지만, 대부분 지도학습이라는 한계를 가지고 있으며, 이는 결국 많은 수의 ground-truth data가 필요하다는 것을 의미한다. 하지만, depth를 기록하는 것은 매우 어려운 문제이다. 따라서 이 연구에서는 얻기 쉬운 binocular stereo footage를 이용하여 문제를 해결한다." />
<meta property="og:description" content="많은 방법론들이 depth estimation부분에서 성과를 보여주었다. 하지만, 대부분 지도학습이라는 한계를 가지고 있으며, 이는 결국 많은 수의 ground-truth data가 필요하다는 것을 의미한다. 하지만, depth를 기록하는 것은 매우 어려운 문제이다. 따라서 이 연구에서는 얻기 쉬운 binocular stereo footage를 이용하여 문제를 해결한다." />
<link rel="canonical" href="https://rroundtable.github.io/FastPages/2019/11/04/Unsupervised-Monocular-Depth-Estimation-with-Left-Right-Consistency-%EC%A0%95%EB%A6%AC%EA%B8%80.html" />
<meta property="og:url" content="https://rroundtable.github.io/FastPages/2019/11/04/Unsupervised-Monocular-Depth-Estimation-with-Left-Right-Consistency-%EC%A0%95%EB%A6%AC%EA%B8%80.html" />
<meta property="og:site_name" content="fastpages" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-11-04T00:00:00-06:00" />
<script type="application/ld+json">
{"datePublished":"2019-11-04T00:00:00-06:00","headline":"Abstract","mainEntityOfPage":{"@type":"WebPage","@id":"https://rroundtable.github.io/FastPages/2019/11/04/Unsupervised-Monocular-Depth-Estimation-with-Left-Right-Consistency-%EC%A0%95%EB%A6%AC%EA%B8%80.html"},"description":"많은 방법론들이 depth estimation부분에서 성과를 보여주었다. 하지만, 대부분 지도학습이라는 한계를 가지고 있으며, 이는 결국 많은 수의 ground-truth data가 필요하다는 것을 의미한다. 하지만, depth를 기록하는 것은 매우 어려운 문제이다. 따라서 이 연구에서는 얻기 쉬운 binocular stereo footage를 이용하여 문제를 해결한다.","@type":"BlogPosting","url":"https://rroundtable.github.io/FastPages/2019/11/04/Unsupervised-Monocular-Depth-Estimation-with-Left-Right-Consistency-%EC%A0%95%EB%A6%AC%EA%B8%80.html","dateModified":"2019-11-04T00:00:00-06:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
  <link rel="stylesheet" href="/FastPages/assets/main.css">
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://rroundtable.github.io/FastPages/feed.xml" title="fastpages" />

  <script>
  function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
  }
  window.onload = wrap_img;
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function(){
      // add link icon to anchor tags
      var elem = document.querySelectorAll(".anchor-link")
      elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
      // remove paragraph tags in rendered toc (happens from notebooks)
      var toctags = document.querySelectorAll(".toc-entry")
      toctags.forEach(e => (e.firstElementChild.innerText = e.firstElementChild.innerText.replace('¶', '')))
    });
  </script>

  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

</head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/FastPages/">fastpages</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/FastPages/about/">About Me</a><a class="page-link" href="/FastPages/search/">Search</a><a class="page-link" href="/FastPages/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Abstract</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2019-11-04T00:00:00-06:00" itemprop="datePublished">
        Nov 4, 2019
      </time>
    •<span class="read-time" title="Estimated read time">
    
    
      5 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>많은 방법론들이 depth estimation부분에서 성과를 보여주었다. 하지만,  대부분 지도학습이라는 한계를 가지고 있으며, 이는 결국 많은 수의 ground-truth data가 필요하다는 것을 의미한다. 하지만, depth를 기록하는 것은 매우 어려운 문제이다. 따라서 이 연구에서는 얻기 쉬운 binocular stereo footage를 이용하여 문제를 해결한다.</p>

<p>epipolar geometry constraints를 활용해서 reconstruction loss로 학습을 시킬 수 있다. 하지만 이 결과물은 depth image의 질이 낮아진다. 이러한 문제를 해결하기 위해서,  consistency를 유지할 수 있게하는 loss를 제안한다.</p>

<blockquote>
  <p><strong>Epipolar geometry</strong></p>

  <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Aufnahme_mit_zwei_Kameras.svg/250px-Aufnahme_mit_zwei_Kameras.svg.png" /></p>

  <p>stereo vision의 geometry,</p>

  <p>2개의 각기 다른 위치에서 3D 이미지의 정보를 얻을 때. 3D points와 2D points간의 많은 기하학적 관계가 있다.</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>이전의 많은 연구들이 multiple observation이 가능하다는 가정아래에서 진행되었다. multiple viewpoint와 다른 조명조건에서의 data도 필요하다. 이러한 한계를 극복하기 위해서, supervised learning방식으로 mono depth estimation 방법론들이 연구되었다. 이러한 방법론들은 많은 수의 data를 기반으로 depth를 직접적으로 추정하고자 하였다. 많은 성과를 이루었지만, 데이터의 수가 많아야된다는 한계를 가지고 있다.(depth 관련 데이터를 수집하기는 힘들다)</p>

<p>image의 외관과 관계없이 장면의 모양을 이해할 수 있는 것은 machine perception분야에서 매우 중요한 이슈이다.</p>

<p>사람은 monocular depth estimation을 잘하는데 이를 위해서 다음과 같은 힌트를 사용한다.</p>

<ul>
  <li>원근법</li>
  <li>이미 알려진 물체크기로 상대적인 추정</li>
  <li>조명 혹은 그림자 가려진 상태에서의 모양</li>
  <li>etc</li>
</ul>

<p>위와 같은 top-down, bottom-up 힌트들을 조합해서 정확하게 depth를 추정할 수 있다. 이 연구에서는 depth data가 필요하지 않다. 학습과정에서는 synthesize depth를 이용한다.  두 이미지(left view, right view) 사이에서 해당 모델은 pixel level의 예측을 한다. (regression) 다른 연구에서도 이와 같은 방법론을 사용했지만 아래와 같은 한계가 존재한다.</p>

<ul>
  <li>memory issue</li>
  <li>not fully diferentiable</li>
</ul>

<h2 id="related-work">Related Work</h2>

<h3 id="learning-based-stereo-between-two-images">Learning-Based Stereo: between two images</h3>

<p>대게 stereo estimation은 첫번째 이미지의 특정 픽셀과 두번째 이미지의 모든 pixel간의 similarity를 계산하는 알고리즘이다. 대부분의 stereo pairs는 정제되어 있으며, disparity estimation은 각 pixel의 1D search 문제이다.</p>

<p>하지만, 최근 연구에 따르면,  head defined similarity measure방법론보다 matching function을 일종의 supervised learning problem으로 두고 문제를 해결하는 것이 더 좋은 성능을 보였다. 특히 Mayer et al.fully convolutional deep network를 활용하여 DispNet을 고안하였다.  이 방법론은 매우 많은 수의 ground-truth data가 필요했다.</p>

<h3 id="supervised-single-image-depth-estimation">Supervised Single Image Depth Estimation</h3>

<p>Saxena et al. patch based model(<a href="http://make3d.cs.cornell.edu/">Make3D</a>)을 제안하였다. 이는 laser scan data를 이용하여 학습되었으며 prediction은 MRF를 활용하여 결합하였다. 이 방법론의 단점은 얇은 구조물을 modeling하는데 적절하지 않았다. 이는 현실적인 이미지를 만드는데 적절치 않다는 것을 의미한다.</p>

<p>위의 방법론은 hand tuning이 필요하다. 이런 방법론과 다르게, Liu et al은 CNN을 이용하여 이를 학습하고자 했다.</p>

<p>Karsch et al. consistent한 image output을 가질려고 노력했다. 이는 training set으로부터 depth image를 복사하여 이루어졌다. 따라서 이 방법론은 test할 때, 모든 training set이 필요하다는 한계를 가진다.</p>

<p>Eigen et al.은 두개의 scale deep network를 활용해서 depth estimation이 가능하다는 것을 보였다. 이들은 hand craft feature를 사용하지 않았고, initial over segmentation을 이용하지 않았다. 대신에 raw pixel value를 활용하여, representation을 하였다.</p>

<p>많은 연구들이 CRF기반으로 accuracy향상을 이루었다.</p>

<h3 id="unsupervised-depth-estimation">Unsupervised Depth Estimation</h3>

<p>Flynne et al.의 DeepStereo는 새로운 view의 이미지를 만들어낸다. 학습하는동안,  다양한 카메라의 상대적인 pose가 근처 이미지의 모습을 만들어내는데 사용된다. test할 때, image synthesis는 겹치는 작은 patch에서 작동한다. 이 모델은 근처의 다른 posed image의 view가 필요하므로,  monocular depth estimation에 부적절하다.</p>

<p>Xie et al의 Deep3D의 목표는 left image 기반으로 right view이미지를 만들어내는 것이다. reconstruction loss를 활용하며,  각 픽셀에 대해서 가능한 disparities에 대해서 분포를 만들어낸다. 이 방법론의 단점은 scalable하지 않다는 것이다. 가능한 disparities가 많아질수록 많은 memory가 필요하다.</p>

<p>해당연구와 비슷한 연구는 Garg et al이 제안하였다. 이 nework는 monocular depth estimation방법론이긴 하지만, fully differentiable하지 않다는 한계를 가진다. 이런 점을 극복하기 위해서 taylor approximation을 사용하였다.</p>

<h2 id="method">Method</h2>

<h3 id="1-depth-estimation-as-image-reconstruction">1. Depth Estimation as Image Reconstruction</h3>

<p>해당 연구에서는 직접 depth를 추정하는 것이 아니라 image reconstruction을 이용하여 추정한다. 기존의 연구에서는 depth estimation문제를 supervised task로 인식해서 해결했지만, 앞서 설명했듯이 depth ground truth data를 구하는 것은 매우 힘든 일이다. 비싼 하드웨어를 사용하더라고 실제환경에서는 정확하지 않을 수 있다.</p>

<p>이 연구에서는 training과정에서 image reconstruction을 활용하여 해결한다. 메인 아이디어는 left-view image에서 right-view image를 만들 수 있는function을 구할 수 있다면, 3D shape에 대한 지식을 알고 있는 것이라고 볼 수 있다.(right view -&gt; left-view도 마찬가지)</p>

<p>left-view image로부터 right-view image를 만든다음에 각 픽셀이 가지는 depth value를 추정한다.</p>

<blockquote>
  <p>Image disparity</p>

  <p>https://www.quora.com/What-are-disparity-maps-and-How-are-they-created</p>

  <ul>
    <li>baseline distance between the camera and the camera focal length $f$: $b$</li>
    <li>image disparity: $d$</li>
    <li>depth $\hat{d} = bf/d$</li>
  </ul>
</blockquote>

<h3 id="2--depth-estimation-network">2.  Depth Estimation Network</h3>

<blockquote>
  <p>Disparity map</p>

  <p><img src="https://i.stack.imgur.com/tECoA.png" /></p>
</blockquote>

<p>이 연구에서는 left-to-right , right-to-left disparities를 모두 구할 수 있으며, 서로 consistency를 유지하게 함으로써 더 좋은 성능을 가져온다.  아래는 기존의 연구의 architecture와 해당 연구의 architecture를 보여주고 있다.</p>

<p><img src="https://user-images.githubusercontent.com/27891090/68211370-c6a3e180-001a-11ea-944e-c70cf85c7cad.png" /></p>

<p>오른쪽 이미지를 보면, left image를 가지고 right image를 생성해낸다. 하지만, 우리는 right-view image에서 sampling된 left-view image가 필요하다.  No LR을 보면 right-view image에서 left view image를 생성한다. 하지만 이는 texture-copy artifact라는 현상을 보이며, detph가 연속적이지 않은 부분에서 error가 많이 발생한다. 아래의 이미지를 보면 알 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/27891090/68212304-9bba8d00-001c-11ea-8cb0-9753fca7f09a.png" /></p>

<p>이 연구에서는 이 문제를 model이 두가지 disparity map를 생성해내도록 만들어서 해결하였다. (sampling from the opposite input images) 이 방법은 여전히 left-view image하나만 필요하며, right image는 training과정에서만 사용된다. left-right consistency loss를 이용하여, 더 정확한 정확도를 가질 수 있다.</p>

<h3 id="3-training-loss">3. Training Loss</h3>

<script type="math/tex; mode=display">C = \Sigma_{s=1}^4C_s</script>

<script type="math/tex; mode=display">C_{s} = \alpha_{ap}(C_{ap}^l + C_{ap}^r) + \alpha_{ds}(C_{ds}^l + C_{ds}^r) + \alpha_{lr}(C_{lr}^l + C_{lr}^r)</script>

<ul>
  <li>Apperance Matching Loss: $C_{ap}$</li>
  <li>Disparity Smoothness Loss: $C_{ds}$</li>
  <li>Left-Right Disparity Consistency: $C_{lr}$</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/27891090/68212839-b6413600-001d-11ea-89cf-2e89ac8071a2.png" /></p>

<p><strong>Apperance Matching Loss</strong>는 oposite setero이미지로부터 image를 생성하도록 학습시킨다. 여기서는 spatial transformer network를 사용하여 disparity map을 만든다. 여기서 bilinear sampler를 사용하는데 locally fully differentiable하며 fully convolutional architecture를 가진다.</p>

<p><script type="math/tex">C_{ap}^l = \frac{1}{N}\Sigma_{i, j}\alpha\frac{1 -SSIM(I_{ij}^l, \hat{I}_{i,j}^l)}{2} + (1 - \alpha)\rVert I_{ij}^l - \hat{I}_{i,j}^l \rVert</script>
이 연구에서는 $\alpha$ 는 0.85 SSIMd에서는 3 x 3 block filter를 사용했다.</p>

<blockquote>
  <p>SSIM: structural similarity</p>

  <p>사람의 시각 시스템은 이미지에서 구조 정보를 도출하는데 특화되어 있기 때문에 구조 정보의 왜곡정도가 지각 품질에 가장 큰 영향을 미친다. 이것이 SSIM의 기본이 되는 핵심가설이다. 구체적으로는 원본 이미지 x와 왜곡 이미지 y의 brightness, contrast, structure를 비교한다.</p>

  <ul>
    <li>
      <p>brightness</p>

      <p>$u_x$: x 이미지의 평균밝기</p>

      <p>$u_y$: y 이미지의 평균 밝기</p>

      <p>$I(x, y) = \frac{2u_xu_y + C_1}{u_x^2 + u_y^2 + C_2}$</p>
    </li>
    <li>
      <p>contrast</p>

      <p>$C(x, y) = \frac{2\sigma_x\sigma_y+C_2}{\sigma_x^2 + \sigma_y^2 + C_2}$</p>
    </li>
    <li>
      <p>structure</p>

      <p>structure = $\frac{x-u_x}{\sigma_x}$</p>

      <p>$S(x, y) = \frac{\sigma_{xy} + C_3}{\sigma_x\sigma_y + C_3}$</p>
    </li>
    <li>
      <p>SSIM</p>

      <p>$SSIM(x,y) = I(x,y)C(c,y)S(x,y)$</p>

      <p>$SSIM(x, y)= \frac{(2u_xu_y + C_1) (2\sigma_{xy} +C_2)}{(u_x^2 + u_y^2 + C_1)(\sigma_x^2 + \sigma_y^2 +C_2)}$</p>
    </li>
  </ul>
</blockquote>

<p><strong>Disparity Smoothness Loss</strong>의 경우에는 아래와 같이 수식으로 표현된다. 이는 disparities가 locally smooth하게 하는 효과를 가져온다.
<script type="math/tex">D_{ds}^l = \frac{1}{N}\Sigma_{i,j}\rvert \partial_{x}d_{i,j}^l\rvert e ^{\rVert \partial_{x}I_{i,j}\rVert} + \rvert \partial_y d_{i,j}^l \rvert e ^{\rVert\partial_y I_{i,j}\rVert}</script></p>

<p><strong>Left-Right Disparity Consistency Loss</strong> 는 더 정확한 disparity map을 만들기 위한 term이다.  이 term은 left-view disparity map을 projected right-view disparity map과 동일하게 만들어주는 역할을 한다.
<script type="math/tex">C_{lr} ^l = \frac{1}{N}\Sigma_{i,j}\rvert d_{ij}^l - d_{ij+d_{ij}^l} ^r \rvert</script></p>

  </div><a class="u-url" href="/FastPages/2019/11/04/Unsupervised-Monocular-Depth-Estimation-with-Left-Right-Consistency-%EC%A0%95%EB%A6%AC%EA%B8%80.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/FastPages/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">fastpages</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">fastpages</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list">
  <li><a href="https://github.com/RRoundTable"><svg class="social svg-icon"><use xlink:href="/FastPages/assets/minima-social-icons.svg#github"></use></svg> <span class="username">RRoundTable</span></a></li><li><a href="https://www.twitter.com/fastdotai"><svg class="social svg-icon"><use xlink:href="/FastPages/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">fastdotai</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>An easy to use blogging platform with support for Jupyter Notebooks.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
