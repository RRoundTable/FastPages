<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" type="image/x-icon" href="/FastPages/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>RAPP: NOVELTY DETECTION WITH RECONSTRUCTION ALONG PROJECTION PATHWAY 정리글 | RoundTable</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="RAPP: NOVELTY DETECTION WITH RECONSTRUCTION ALONG PROJECTION PATHWAY 정리글" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Abstract" />
<meta property="og:description" content="Abstract" />
<link rel="canonical" href="https://rroundtable.github.io/FastPages/2020/04/02/RaPP.html" />
<meta property="og:url" content="https://rroundtable.github.io/FastPages/2020/04/02/RaPP.html" />
<meta property="og:site_name" content="RoundTable" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-02T00:00:00-05:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://rroundtable.github.io/FastPages/2020/04/02/RaPP.html"},"description":"Abstract","@type":"BlogPosting","url":"https://rroundtable.github.io/FastPages/2020/04/02/RaPP.html","headline":"RAPP: NOVELTY DETECTION WITH RECONSTRUCTION ALONG PROJECTION PATHWAY 정리글","dateModified":"2020-04-02T00:00:00-05:00","datePublished":"2020-04-02T00:00:00-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
  <link rel="stylesheet" href="/FastPages/assets/main.css">
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://rroundtable.github.io/FastPages/feed.xml" title="RoundTable" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
          ]}
        );
      });
    </script>
  

  <script>
  function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
  }
  window.onload = wrap_img;
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function(){
      // add link icon to anchor tags
      var elem = document.querySelectorAll(".anchor-link")
      elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
      // remove paragraph tags in rendered toc (happens from notebooks)
      var toctags = document.querySelectorAll(".toc-entry")
      toctags.forEach(e => (e.firstElementChild.innerText = e.firstElementChild.innerText.replace('¶', '')))
    });
  </script>

  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

</head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/FastPages/">RoundTable</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/FastPages/about/">About Me</a><a class="page-link" href="/FastPages/">Posts</a><a class="page-link" href="/FastPages/search/">Search</a><a class="page-link" href="/FastPages/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">RAPP: NOVELTY DETECTION WITH RECONSTRUCTION ALONG PROJECTION PATHWAY 정리글</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-04-02T00:00:00-05:00" itemprop="datePublished">
        Apr 2, 2020
      </time>
    •<span class="read-time" title="Estimated read time">
    
    
      3 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#abstract">Abstract</a></li>
<li class="toc-entry toc-h2"><a href="#introduction">Introduction</a></li>
<li class="toc-entry toc-h2"><a href="#proposed-method-rapp">Proposed Method RaPP</a>
<ul>
<li class="toc-entry toc-h3"><a href="#reconstruction-based-novelty-detection">Reconstruction Based Novelty Detection</a></li>
<li class="toc-entry toc-h3"><a href="#reconstruction-error-in-hidden-spaces">Reconstruction Error In Hidden Spaces</a></li>
<li class="toc-entry toc-h3"><a href="#simple-aggregation-along-pathwaysap">Simple Aggregation Along Pathway(SAP)</a></li>
<li class="toc-entry toc-h3"><a href="#normalized-aggregation-along-pathwaynap">Normalized Aggregation Along Pathway(NAP)</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#motivation-of-rapp">Motivation Of RAPP</a>
<ul>
<li class="toc-entry toc-h3"><a href="#computation-of-hidden-reconstruction">Computation Of Hidden Reconstruction</a></li>
<li class="toc-entry toc-h3"><a href="#existence-of-f_tilde">Existence of f_tilde</a></li>
<li class="toc-entry toc-h3"><a href="#existence-of-f_tilde-with-neural-networks">Existence of f_tilde With Neural Networks</a></li>
</ul>
</li>
</ul><h2 id="abstract">
<a class="anchor" href="#abstract" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract</h2>

<p>autoencoder를 활용하여 anomaly detection을 수행하는 시도들이 있다. 하지만, 이러한 방법론은 주로 input과 reconstruct된 output간의 차이에 집중하고, hidden space간의 관계에 대해서는 고려하지 않는다는 한계를 가지고 있다. 본 연구에서는 autoencoder 구조를 바탕으로 input space와 output간의 관계뿐만 아니라, hidden space간의 관계를 고려하는 방법을 제안한다. (encoder hidden space와 대응되는 decoder hidden space와 비교) 또한,  reconstructed된 output을 다시 동일한 autoencoder에 넣어서 발생되는 activation value가 original input을 동일한 모델에 넣었을때의 대응되는 decoder activation value와 동일하다는 것을 보였다.</p>

<h2 id="introduction">
<a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>아쉽게도 encoder hidden space와 대응되는 decoder hidden space를 비교하는 것은 불가능하다. <strong>왜냐하면, 학습이 진행되는 동안은 모델이 불안정하며 encoder-decoder layer pair가 대응된다고 볼 수 없기 때문이다.</strong>  하지만 reconstructed된 output을 다시 동일한 autoencoder에 넣어서 발생되는 activation value가 original input을 동일한 모델에 넣었을때의 대응되는 decoder activation value와 동일하다는 것을 보임으로써 문제를 해결할 수 있었다.</p>

<p><strong>Contributions</strong></p>

<ul>
  <li>hidden space도 함께 활용한 방법론</li>
  <li>RaPP의 motivation 소개 및 증명</li>
  <li>RaPP의 성능 증명</li>
</ul>

<h2 id="proposed-method-rapp">
<a class="anchor" href="#proposed-method-rapp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proposed Method RaPP</h2>

<p><img src="/images/2020-04-02-RaPP/img1.png" alt="" title="hidden space"></p>

<p>위의 이미지 처럼 encoder와 decoder간의 hidden space를  비교하는 것이 목표이지만, 위에서 언급한 한계때문에 불가능하다.  그래서 새롭게 제안하는 방법은 reconstruction output을 다시 autoencoder에 넣어서 decoder의 hidden space들을 재현하는 것이다.</p>

<h3 id="reconstruction-based-novelty-detection">
<a class="anchor" href="#reconstruction-based-novelty-detection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reconstruction Based Novelty Detection</h3>

<p>autoencoder $A$ 는 unsupervised 방법을 바탕으로 의미있는 representation을 만들어내며, 아래는 사용되는 objective이다.
<script type="math/tex">\epsilon = \mid \mid x - A(x) \mid \mid _2 \ \ \ \ \ \ \text{whrere A = f(g(x)) }</script>
또한, $\epsilon(x)$가 높다면, anomaly일 가능성이 높아진다고 해석할 수 있다. 하지만, 모델의 구조가 깊어질수록 hierarchical information을 활용하지 못하는 점에서 아쉬움이 남는다. 딥러닝 모델의 모든 layer를 충분히 활용하려면 결국 hidden space를 잘 활용할 필요가 있다.</p>

<h3 id="reconstruction-error-in-hidden-spaces">
<a class="anchor" href="#reconstruction-error-in-hidden-spaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reconstruction Error In Hidden Spaces</h3>

<p><img src="/FastPages/images/2020-04-02-RaPP/figure1_a.png" alt="" title="Figure1 (a)"></p>

<p>위에 보이는 이미지처럼, $h_i(x), \hat{h}_i(x)$를 각각 구한다.</p>

<p>다음과 같은 encoder를 정의하면 위의 과정을 전개할 수 있다.
<script type="math/tex">g_{:i} = g_i \circ \cdots \circ g1</script></p>

<script type="math/tex; mode=display">h_i(x) = g_{:i} \\
\hat{h_i(x)} = g_{:i}(\hat{x}) = g_{:i}(A(x)) \ \ \ \text{where A is autoencoder}</script>

<p>그리고 위와 같은 hidden space value들을 decoder hidden space의 수 만큼 모아준다. 
<script type="math/tex">H(x) = \{ (h_i(x), \hat{h}_i(x)) : i \le i \le l \}</script>
$H(x)$를 활용해서 novelty score를 얻기 위해 다음과 같은 과정을 진행한다.</p>

<p><img src="/FastPages/images/2020-04-02-RaPP/algorithm1.png" alt="" title="Algorithm1"></p>

<p>여기서 $S$ 는 novelty score를 측정하는 함수로 본 연구에서는 크게 두 가지 방향을 제시한다.</p>

<h3 id="simple-aggregation-along-pathwaysap">
<a class="anchor" href="#simple-aggregation-along-pathwaysap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple Aggregation Along Pathway(SAP)</h3>

<p>두 hidden space간의 Euclidean distance를 구한다.</p>

<script type="math/tex; mode=display">S_{SAP}(x) = \sum_{i=0}^l  \mid \mid h_i(x) - \hat{h}_i(x) \mid \mid_2^2 = \mid \mid h(x) - \hat{h}_i(x) \mid \mid _x^2</script>

<h3 id="normalized-aggregation-along-pathwaynap">
<a class="anchor" href="#normalized-aggregation-along-pathwaynap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Normalized Aggregation Along Pathway(NAP)</h3>

<p>위의 SAP 방법은 각 hidden space간의 특성은 고려하지 못한다. 각 pair마다 distance distribution이 다르게 나타날 수 있는데 이러한 문제를 해결하기 위해서 orthogonalization과 scaling을 통한 normalization 방법을 제안한다.</p>

<script type="math/tex; mode=display">S_{NAP}(x) = \mid \mid d(x) - uX)^T V\Sigma^{-1} \mid \mid_2^2</script>

<ul>
  <li>$d(x) = h(x) - \hat{h}(x)$</li>
  <li>$D$ 는 matrix이며 각 row i는 data point $x_i$가 가지고 있는 pair들의 distance들로 이루어져있다.</li>
  <li>$\bar{D}  $는 $D$의 column wise centered matrix 이다.</li>
  <li>normalization을 위해서 SVD를 수행한다. $\bar{D} = U \Sigma V^T$</li>
</ul>

<h2 id="motivation-of-rapp">
<a class="anchor" href="#motivation-of-rapp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation Of RAPP</h2>

<p>‘hidden space정보를 활용할 수 있지 않을까’라는 동기에서 연구가 출발했다. 하지만, 이런 문제의식을 가지더라도 해결해야될 이슈가 있다. 대응하는 encoder decoder의 layer pair가 서로 같은 space를 표현한다고 할 수 없다. <strong>왜냐하면, autoencoder의 objective는 각 layer에 들어오는 input에 대해서 어떤 제약도 하지 않기 때문이다. 결과적으로 $f_{l:i+1}(g(x)) = g_{:i}(x)$과 같은 관계가 성립한다고 볼 수 없다.</strong></p>

<p>그럼에도 불구하고, $\hat{h}<em>i(x) = g</em>(A(x))$의 관계를 바탕으로, 위의 문제의식을 실현할 수 있었다. 전반적인 프로세스는 아래의 Figure1 (b)를 확인하면 알 수 있다.</p>

<p><img src="/FastPages/images/2020-04-02-RaPP/figure1_b.png" alt="" title="Figure1 (b)"></p>

<h3 id="computation-of-hidden-reconstruction">
<a class="anchor" href="#computation-of-hidden-reconstruction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Computation Of Hidden Reconstruction</h3>

<ul>
  <li>$A = f \circ g$은 학습된 autoencoder라고 가정한다.</li>
  <li>$M_0 = { A(x):  x \in R^n }$은 reconstruction된 output 집합이다.
    <ul>
      <li>$A$는 다음과 같이 표현된다. $ x\in M_0, x= A(x)$</li>
      <li>해석하자면, reconstruction된 결과를 다시 autoencoder에 넣으면 input으로 넣은 reconstruction과 동일하다는 것이다.</li>
    </ul>
  </li>
  <li>$M_i = { g_{:i(x)}: x \in M_0 }$</li>
</ul>

<p><img src="/FastPages/images/2020-04-02-RaPP/figure1_b.png" alt="" title="M"></p>

<p>다음과 같은 decoder $\tilde{f}$ 가 있다고 가정하자.
<script type="math/tex">x \in M_l, \tilde{f}(x) = f(x)\\  
a \in M_i, a = (g_i \circ \tilde{f})(a)</script></p>

<p>첫 번째 조건 $x \in M_l, \tilde{f}(x) = f(x)\ $은 feed foward의 결과가 같다는 것을 의미한다.</p>

<p>두 번째 조건$a \in M_i, a = (g_i \circ \tilde{f})(a)$은 $\tilde{f}<em>{l:i+1}$과 $g</em>{i+1:}$이 서로 적합한 encoder decoder의 pair로 만들어준다. 즉 서로 inverse의 관계를 가진다.  따라서 다음과 같은 수식 전개가 가능하다.
<script type="math/tex">\hat{h^{'}}_i = (\tilde{f}_{l:i+1} \circ g_{i+1:})(h_i(x))</script>
이는 Figure1 (b)를 보면, 어떤 의미인지 알 수 있다. 간략히 설명하면, decoder 부분의 hidden space다.</p>

<p>그리고 다음과 같은 과정을 통해서 $\hat{h^{‘}}_i(x) = \hat{h}_i(x)$임을 증명할 수 있다.
<script type="math/tex">% <![CDATA[
\begin{aligned}
\begin{split}
\hat{h^{'}}_i(x) = (\tilde{f}_{l:i+1} \circ g_{i+1:})(h_i(x))
&= (\tilde{f}_{l:i+1} \circ g)(x) \\
&= (g_{:i} \circ \tilde{f} \circ g)(x) \\
&= (g_{:i} \circ A)(x) = h_i(\hat{x}) = \hat{h}_i(x)
\end{split}
\end{aligned} %]]></script></p>

<p>주목할 점은 $\hat{h^{‘}}_i$을 얻기 뒤해서 $\tilde{f}_i$가 필요하지 않다는 것이다. 그리고 $x \in M_0$에 대해서는 다음과 같은 관계도 성립한다.
<script type="math/tex">h_i(x) = \hat{h}_i(x) = \hat{h^{'}}_i(x), \mbox{    for every   } 1  \le i \le l</script></p>

<h3 id="existence-of-f_tilde">
<a class="anchor" href="#existence-of-f_tilde" aria-hidden="true"><span class="octicon octicon-link"></span></a>Existence of f_tilde</h3>

<p>전제조건은 다음과 같다.</p>

<ul>
  <li>$x = A(x) \text{   for } x \in M_0$</li>
  <li>$g_i(x: x \in M_{i-1}) = \hat{x}: \hat{x} \in M_i$</li>
  <li>$f_i(x: x \in M_{i-1}) = \hat{x}: \hat{x} \in M_i$</li>
</ul>

<p>여기에 다음과 같이 정의해보자.</p>

<p>$\tilde{f}_i =g_i^{-1} \text{    for  } M_i$이라면, 이런관계가 성립한다.   $\tilde{f} = g^{-1}$
해석하면, 각 encoder decoder layer pair에 대해서 inverse 관계가 성립하게 되면, encoder decoder에 대해서도 inverse 관계가 성립하게 된다.</p>

<p>이런 정의는 아래와 같은 조건을 충족시킨다.</p>

<script type="math/tex; mode=display">x = (\tilde{f} \circ g)(x) \text{   for  } x \in M_0</script>

<p>$x = A(x)$ 라는 전제조건을 생각해보면,</p>

<script type="math/tex; mode=display">\tilde{f} = f \text{ on } M_l</script>

<h3 id="existence-of-f_tilde-with-neural-networks">
<a class="anchor" href="#existence-of-f_tilde-with-neural-networks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Existence of f_tilde With Neural Networks</h3>

<p>neural network는 유연한 구조를 가졌기때문에, 특정 함수를 쉽게 근사할 수 있다.</p>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="RRoundTable/FastPages"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/FastPages/2020/04/02/RaPP.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/FastPages/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">RoundTable</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">RoundTable</li><li><a class="u-email" href="mailto:ryu071511@gmail.com">ryu071511@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list">
  <li><a href="https://github.com/RRoundTable"><svg class="social svg-icon"><use xlink:href="/FastPages/assets/minima-social-icons.svg#github"></use></svg> <span class="username">RRoundTable</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Tech Blog for RoundTable</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
